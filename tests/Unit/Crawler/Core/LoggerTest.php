<?php

/**
 * LoggerTest - Ultra-Strict Enterprise Unit Tests.
 *
 * Tests distributed tracing, multi-channel output, correlation IDs,
 * performance metrics, security event logging with maximum rigor.
 *
 * Target Coverage: 100%
 * Edge Cases: Comprehensive
 * Enterprise Standards: ISO 25010, OWASP
 */

declare(strict_types=1);

namespace CIS\SharedServices\Crawler\Tests\Unit\Core;

use CIS\SharedServices\Crawler\Core\Logger;
use Exception;
use Mockery;
use PHPUnit\Framework\TestCase;
use ReflectionClass;
use RuntimeException;
use stdClass;

use function strlen;

class LoggerTest extends TestCase
{
    private Logger $logger;

    private string $testLogPath;

    private array $mockHandlers;

    protected function setUp(): void
    {
        parent::setUp();

        $this->testLogPath = sys_get_temp_dir() . '/crawler_test_' . uniqid() . '.log';

        $this->mockHandlers = [
            'file'   => ['path' => $this->testLogPath, 'enabled' => true],
            'stdout' => ['enabled' => false], // Disabled for testing
            'redis'  => ['enabled' => false],  // Mock Redis separately
        ];

        $this->logger = new Logger([
            'app_name'        => 'test_crawler',
            'min_level'       => 'debug',
            'handlers'        => $this->mockHandlers,
            'include_context' => true,
            'include_trace'   => true,
        ]);
    }

    protected function tearDown(): void
    {
        if (file_exists($this->testLogPath)) {
            unlink($this->testLogPath);
        }
        Mockery::close();
        parent::tearDown();
    }

    /**
     * Helper to safely read log file content.
     *
     * @return string
     */
    private function getLogContent(string $path = null): string
    {
        $path = $path ?? $this->testLogPath;
        $content = file_get_contents($path);
        $this->assertIsString($content, "Failed to read log file: {$path}");
        return $content;
    }

    // =========================================================================
    // LOG LEVEL FILTERING TESTS
    // =========================================================================

    public function testDebugLevelIsLowest(): void
    {
        $this->logger->debug('Debug message');

        $this->assertFileExists($this->testLogPath);
        $content = $this->getLogContent();
        $this->assertStringContainsString('DEBUG', $content);
        $this->assertStringContainsString('Debug message', $content);
    }

    public function testInfoLevelLogged(): void
    {
        $this->logger->info('Info message');

        $content = $this->getLogContent();
        $this->assertStringContainsString('INFO', $content);
        $this->assertStringContainsString('Info message', $content);
    }

    public function testWarningLevelLogged(): void
    {
        $this->logger->warning('Warning message');

        $content = $this->getLogContent();
        $this->assertStringContainsString('WARNING', $content);
        $this->assertStringContainsString('Warning message', $content);
    }

    public function testErrorLevelLogged(): void
    {
        $this->logger->error('Error message');

        $content = $this->getLogContent();
        $this->assertStringContainsString('ERROR', $content);
        $this->assertStringContainsString('Error message', $content);
    }

    public function testCriticalLevelLogged(): void
    {
        $this->logger->critical('Critical message');

        $content = $this->getLogContent();
        $this->assertStringContainsString('CRITICAL', $content);
        $this->assertStringContainsString('Critical message', $content);
    }

    public function testMinLevelFilteringWorks(): void
    {
        $logger = new Logger([
            'app_name'  => 'test_crawler',
            'min_level' => 'warning',
            'handlers'  => $this->mockHandlers,
        ]);

        $logger->debug('Should not appear');
        $logger->info('Should not appear');
        $logger->warning('Should appear');

        $content = $this->getLogContent();
        $this->assertStringNotContainsString('Should not appear', $content);
        $this->assertStringContainsString('Should appear', $content);
    }

    // =========================================================================
    // CORRELATION ID TESTS
    // =========================================================================

    public function testCorrelationIDAutoGenerated(): void
    {
        $this->logger->info('Test message');

        $content = $this->getLogContent();
        $this->assertMatchesRegularExpression('/correlation_id":"[a-f0-9]{32}/', $content);
    }

    public function testCorrelationIDPropagation(): void
    {
        $correlationId = $this->logger->startCorrelation();

        $this->logger->info('First message');
        $this->logger->info('Second message');

        $content = $this->getLogContent();

        // Both messages should have same correlation ID
        preg_match_all('/correlation_id":"([a-f0-9]{32})/', $content, $matches);
        $this->assertCount(2, $matches[1]);
        $this->assertEquals($matches[1][0], $matches[1][1]);
    }

    public function testChildCorrelationID(): void
    {
        $parentId = $this->logger->startCorrelation();
        $childId  = $this->logger->createChildCorrelation($parentId);

        $this->assertNotEquals($parentId, $childId);
        $this->assertStringStartsWith(substr($parentId, 0, 8), $childId);
    }

    public function testCorrelationIDInContext(): void
    {
        $customId = 'custom-correlation-id-12345';
        $this->logger->setCorrelationId($customId);

        $this->logger->info('Test with custom correlation');

        $content = $this->getLogContent();
        $this->assertStringContainsString($customId, $content);
    }

    // =========================================================================
    // CONTEXT ENRICHMENT TESTS
    // =========================================================================

    public function testContextArrayLogged(): void
    {
        $this->logger->info('Test message', [
            'user_id' => 123,
            'url'     => 'https://example.com',
            'action'  => 'crawl',
        ]);

        $content = $this->getLogContent();
        $this->assertStringContainsString('user_id', $content);
        $this->assertStringContainsString('123', $content);
        $this->assertStringContainsString('https://example.com', $content);
    }

    public function testNestedContextLogged(): void
    {
        $this->logger->info('Test message', [
            'metadata' => [
                'nested' => [
                    'deep' => 'value',
                ],
            ],
        ]);

        $content = $this->getLogContent();
        $this->assertStringContainsString('deep', $content);
        $this->assertStringContainsString('value', $content);
    }

    public function testTimestampIncluded(): void
    {
        $this->logger->info('Test message');

        $content = $this->getLogContent();
        $this->assertMatchesRegularExpression('/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/', $content);
    }

    public function testMicrosecondPrecision(): void
    {
        $this->logger->info('Test message');

        $content = $this->getLogContent();
        $this->assertMatchesRegularExpression('/\.\d{6}/', $content);
    }

    // =========================================================================
    // PERFORMANCE METRICS TESTS
    // =========================================================================

    public function testDurationMetricLogged(): void
    {
        $this->logger->startTimer('operation');
        usleep(10000); // 10ms
        $duration = $this->logger->stopTimer('operation');

        $this->assertGreaterThan(0.01, $duration);
        $this->assertLessThan(0.05, $duration);
    }

    public function testMemoryMetricLogged(): void
    {
        $memBefore = $this->logger->getCurrentMemoryUsage();

        // Allocate some memory
        $data = str_repeat('x', 1024 * 1024); // 1MB

        $memAfter = $this->logger->getCurrentMemoryUsage();

        $this->assertGreaterThan($memBefore, $memAfter);
    }

    public function testPerformanceContextAutoAdded(): void
    {
        $this->logger->info('Performance test', [], true); // Enable perf metrics

        $content = $this->getLogContent();
        $this->assertStringContainsString('memory_mb', $content);
        $this->assertStringContainsString('peak_memory_mb', $content);
    }

    // =========================================================================
    // SECURITY EVENT LOGGING TESTS
    // =========================================================================

    public function testSecurityEventMarked(): void
    {
        $this->logger->security('Suspicious activity detected', [
            'ip'         => '192.168.1.100',
            'user_agent' => 'BadBot/1.0',
        ]);

        $content = $this->getLogContent();
        $this->assertStringContainsString('SECURITY', $content);
        $this->assertStringContainsString('192.168.1.100', $content);
    }

    public function testIPAddressEnrichment(): void
    {
        $this->logger->info('Request logged', [
            'ip' => '203.0.113.45',
        ]);

        $content = $this->getLogContent();
        $this->assertStringContainsString('203.0.113.45', $content);
    }

    public function testUserAgentLogging(): void
    {
        $this->logger->info('Request', [
            'user_agent' => 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
        ]);

        $content = $this->getLogContent();
        $this->assertStringContainsString('Mozilla/5.0', $content);
    }

    public function testSensitiveDataRedaction(): void
    {
        $this->logger->info('User action', [
            'password' => 'secret123',
            'api_key'  => 'sk_live_abc123',
            'token'    => 'bearer_xyz789',
        ]);

        $content = $this->getLogContent();
        $this->assertStringNotContainsString('secret123', $content);
        $this->assertStringNotContainsString('sk_live_abc123', $content);
        $this->assertStringContainsString('[REDACTED]', $content);
    }

    // =========================================================================
    // MULTI-CHANNEL OUTPUT TESTS
    // =========================================================================

    public function testFileHandlerWrites(): void
    {
        $this->logger->info('File test');

        $this->assertFileExists($this->testLogPath);
        $this->assertGreaterThan(0, filesize($this->testLogPath));
    }

    public function testFileHandlerRotation(): void
    {
        // Write enough logs to trigger rotation
        for ($i = 0; $i < 100; $i++) {
            $this->logger->info("Log line {$i}");
        }

        $this->assertFileExists($this->testLogPath);
    }

    public function testMultipleHandlersReceiveSameMessage(): void
    {
        $secondLogPath = sys_get_temp_dir() . '/crawler_test2_' . uniqid() . '.log';

        $logger = new Logger([
            'app_name' => 'test_crawler',
            'handlers' => [
                'file1' => ['path' => $this->testLogPath, 'enabled' => true],
                'file2' => ['path' => $secondLogPath, 'enabled' => true],
            ],
        ]);

        $logger->info('Multi-handler test');

        $this->assertFileExists($this->testLogPath);
        $this->assertFileExists($secondLogPath);

        $content1 = $this->getLogContent();
        $content2 = $this->getLogContent($secondLogPath);

        $this->assertStringContainsString('Multi-handler test', $content1);
        $this->assertStringContainsString('Multi-handler test', $content2);

        unlink($secondLogPath);
    }

    // =========================================================================
    // STRUCTURED LOGGING TESTS
    // =========================================================================

    public function testJSONFormatValid(): void
    {
        $this->logger->info('JSON test', ['key' => 'value']);

        $content = $this->getLogContent();
        $lines   = explode("\n", trim($content));

        foreach ($lines as $line) {
            if (empty($line)) {
                continue;
            }
            $decoded = json_decode($line, true);
            $this->assertNotNull($decoded);
            $this->assertIsArray($decoded);
        }
    }

    public function testRequiredFieldsPresent(): void
    {
        $this->logger->info('Field test');

        $content = $this->getLogContent();
        $log     = json_decode(trim($content), true);

        $this->assertArrayHasKey('timestamp', $log);
        $this->assertArrayHasKey('level', $log);
        $this->assertArrayHasKey('message', $log);
        $this->assertArrayHasKey('app_name', $log);
        $this->assertArrayHasKey('correlation_id', $log);
    }

    public function testContextFieldStructure(): void
    {
        $this->logger->info('Context test', [
            'custom_field' => 'custom_value',
        ]);

        $content = $this->getLogContent();
        $log     = json_decode(trim($content), true);

        $this->assertArrayHasKey('context', $log);
        $this->assertIsArray($log['context']);
        $this->assertEquals('custom_value', $log['context']['custom_field']);
    }

    // =========================================================================
    // STACK TRACE TESTS
    // =========================================================================

    public function testStackTraceIncludedOnError(): void
    {
        $this->logger->error('Error with trace', [], true);

        $content = $this->getLogContent();
        $this->assertStringContainsString('trace', $content);
        $this->assertStringContainsString('LoggerTest.php', $content);
    }

    public function testStackTraceExcludedWhenDisabled(): void
    {
        $logger = new Logger([
            'app_name'      => 'test_crawler',
            'handlers'      => $this->mockHandlers,
            'include_trace' => false,
        ]);

        $logger->error('Error without trace');

        $content = $this->getLogContent();
        $log     = json_decode(trim($content), true);

        $this->assertArrayNotHasKey('trace', $log);
    }

    public function testExceptionLogging(): void
    {
        try {
            throw new RuntimeException('Test exception');
        } catch (Exception $e) {
            $this->logger->exception($e);
        }

        $content = $this->getLogContent();
        $this->assertStringContainsString('RuntimeException', $content);
        $this->assertStringContainsString('Test exception', $content);
        $this->assertStringContainsString('trace', $content);
    }

    // =========================================================================
    // CHILD LOGGER TESTS
    // =========================================================================

    public function testChildLoggerInheritsContext(): void
    {
        $this->logger->setContext(['parent_key' => 'parent_value']);
        $childLogger = $this->logger->createChild(['child_key' => 'child_value']);

        $childLogger->info('Child log');

        $content = $this->getLogContent();
        $this->assertStringContainsString('parent_value', $content);
        $this->assertStringContainsString('child_value', $content);
    }

    public function testChildLoggerCorrelationLinked(): void
    {
        $parentId    = $this->logger->startCorrelation();
        $childLogger = $this->logger->createChild();

        $this->logger->info('Parent log');
        $childLogger->info('Child log');

        $content = $this->getLogContent();
        $lines   = explode("\n", trim($content));

        $parentLog = json_decode($lines[0], true);
        $childLog  = json_decode($lines[1], true);

        $this->assertArrayHasKey('parent_correlation_id', $childLog);
        $this->assertEquals($parentLog['correlation_id'], $childLog['parent_correlation_id']);
    }

    // =========================================================================
    // EDGE CASE TESTS
    // =========================================================================

    public function testEmptyMessageLogged(): void
    {
        $this->logger->info('');

        $content = $this->getLogContent();
        $this->assertNotEmpty($content);
    }

    public function testVeryLongMessageTruncated(): void
    {
        $longMessage = str_repeat('x', 10000);
        $this->logger->info($longMessage);

        $content = $this->getLogContent();
        $log     = json_decode(trim($content), true);

        // Message should be truncated to reasonable length
        $this->assertLessThan(5000, strlen($log['message']));
    }

    public function testSpecialCharactersEscaped(): void
    {
        $this->logger->info('Message with "quotes" and \'apostrophes\' and \n newlines');

        $content = $this->getLogContent();
        $log     = json_decode(trim($content), true);

        $this->assertNotNull($log);
        $this->assertStringContainsString('quotes', $log['message']);
    }

    public function testCircularReferenceHandled(): void
    {
        $obj1      = new stdClass();
        $obj2      = new stdClass();
        $obj1->ref = $obj2;
        $obj2->ref = $obj1;

        $this->logger->info('Circular test', ['circular' => $obj1]);

        $content = $this->getLogContent();
        $this->assertNotEmpty($content);
    }

    public function testNullValuesHandled(): void
    {
        $this->logger->info('Null test', [
            'null_value' => null,
            'nested'     => ['also_null' => null],
        ]);

        $content = $this->getLogContent();
        $log     = json_decode(trim($content), true);

        $this->assertNull($log['context']['null_value']);
    }

    public function testBinaryDataHandled(): void
    {
        $binaryData = pack('nvc*', 0x1234, 0x5678, 65, 66);

        $this->logger->info('Binary test', ['binary' => $binaryData]);

        $content = $this->getLogContent();
        $this->assertNotEmpty($content);
    }

    // =========================================================================
    // PERFORMANCE TESTS
    // =========================================================================

    public function testLoggingPerformance(): void
    {
        $start = microtime(true);

        for ($i = 0; $i < 1000; $i++) {
            $this->logger->info("Log message {$i}", ['iteration' => $i]);
        }

        $duration = microtime(true) - $start;

        // Should log 1000 messages in under 1 second
        $this->assertLessThan(1.0, $duration);
    }

    public function testMemoryUsageDuringLogging(): void
    {
        $memBefore = memory_get_usage(true);

        for ($i = 0; $i < 100; $i++) {
            $this->logger->info("Log message {$i}");
        }

        $memAfter = memory_get_usage(true);
        $memUsed  = $memAfter - $memBefore;

        // Should not use more than 5MB for 100 logs
        $this->assertLessThan(5 * 1024 * 1024, $memUsed);
    }

    public function testConcurrentLogging(): void
    {
        // Simulate concurrent logging from multiple "threads"
        $processes      = 10;
        $logsPerProcess = 10;

        for ($p = 0; $p < $processes; $p++) {
            for ($i = 0; $i < $logsPerProcess; $i++) {
                $this->logger->info("Process {$p} log {$i}");
            }
        }

        $content = $this->getLogContent();
        $lines   = explode("\n", trim($content));

        // Should have all logs
        $this->assertCount($processes * $logsPerProcess, array_filter($lines));
    }

    // =========================================================================
    // LOG LEVEL CONSTANTS TESTS
    // =========================================================================

    public function testLogLevelNumericValues(): void
    {
        $reflection = new ReflectionClass($this->logger);

        if ($reflection->hasConstant('LEVEL_DEBUG')) {
            $this->assertEquals(1, $reflection->getConstant('LEVEL_DEBUG'));
            $this->assertEquals(2, $reflection->getConstant('LEVEL_INFO'));
            $this->assertEquals(3, $reflection->getConstant('LEVEL_WARNING'));
            $this->assertEquals(4, $reflection->getConstant('LEVEL_ERROR'));
            $this->assertEquals(5, $reflection->getConstant('LEVEL_CRITICAL'));
        }
    }

    // =========================================================================
    // BATCH LOGGING TESTS
    // =========================================================================

    public function testBatchLoggingFlushes(): void
    {
        if (method_exists($this->logger, 'startBatch')) {
            $this->logger->startBatch();
            $this->logger->info('Batch message 1');
            $this->logger->info('Batch message 2');
            $this->logger->info('Batch message 3');
            $this->logger->flushBatch();

            $content = $this->getLogContent();
            $this->assertStringContainsString('Batch message 1', $content);
            $this->assertStringContainsString('Batch message 2', $content);
            $this->assertStringContainsString('Batch message 3', $content);
        } else {
            $this->markTestSkipped('Batch logging not implemented');
        }
    }

    // =========================================================================
    // FORMATTING TESTS
    // =========================================================================

    public function testCustomFormatterApplied(): void
    {
        if (method_exists($this->logger, 'setFormatter')) {
            $this->logger->setFormatter(function ($log) {
                return strtoupper($log['message']);
            });

            $this->logger->info('lowercase message');

            $content = $this->getLogContent();
            $this->assertStringContainsString('LOWERCASE MESSAGE', $content);
        } else {
            $this->markTestSkipped('Custom formatter not implemented');
        }
    }
}
